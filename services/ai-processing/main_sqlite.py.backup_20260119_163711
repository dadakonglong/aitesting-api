from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import json
import uvicorn
import sqlite3
import os
import httpx
import urllib.parse
from typing import List, Dict, Optional, Any
from datetime import datetime
import re
from pydantic import BaseModel
from dotenv import load_dotenv

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

app = FastAPI(title="AI Testing API - Unified Edition")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# è·¯å¾„é…ç½®
BASE_DIR = "D:/testc/aitesting-api"
DB_PATH = os.path.join(BASE_DIR, "data/apis.db")

# ============= æ¨¡å‹é€‚é…å±‚ =============

from openai import AsyncOpenAI

class AIProvider:
    def __init__(self):
        self.openai_key = os.getenv("OPENAI_API_KEY")
        self.openai_model = os.getenv("OPENAI_MODEL", "gpt-4")
        self.deepseek_key = os.getenv("DEEPSEEK_API_KEY")
        self.deepseek_model = os.getenv("DEEPSEEK_MODEL", "deepseek-chat")
        self.deepseek_base_url = os.getenv("DEEPSEEK_BASE_URL", "https://api.deepseek.com")
        self.default_provider = os.getenv("AI_PROVIDER", "openai").lower()

    def get_client(self, provider: str) -> AsyncOpenAI:
        """æ ¹æ®ä¾›åº”å•†è·å–å¯¹åº”çš„ SDK å®¢æˆ·ç«¯ (å¼ºåˆ¶ç¦ç”¨ä»£ç†ä»¥è§£å†³ SSL é”™è¯¯)"""
        # åˆ›å»ºä¸€ä¸ªå¹²å‡€çš„ http_client
        http_client = httpx.AsyncClient(
            timeout=60.0,
            trust_env=False,  # ç¦ç”¨ç³»ç»Ÿä»£ç†
            verify=True       # ä¿æŒ SSL éªŒè¯
        )
        
        if provider == "deepseek":
            return AsyncOpenAI(
                api_key=self.deepseek_key,
                base_url=self.deepseek_base_url,
                http_client=http_client
            )
        else:
            return AsyncOpenAI(
                api_key=self.openai_key,
                http_client=http_client
            )

    async def chat(self, system_prompt: str, user_prompt: str, provider: str = None) -> Dict:
        """ä½¿ç”¨ OpenAI SDK è°ƒç”¨æ¥å£ï¼ˆå…¼å®¹ DeepSeekï¼‰"""
        active_provider = provider or self.default_provider
        client = self.get_client(active_provider)
        model = self.deepseek_model if active_provider == "deepseek" else self.openai_model

        print(f"ğŸ“¡ SDK è°ƒç”¨å¼€å§‹ | Provider: {active_provider} | Model: {model}")
        try:
            response = await client.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                response_format={"type": "json_object"},
                temperature=0.3
            )
            print(f"âœ… AI å“åº”æˆåŠŸ")
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            print(f"âŒ AI è°ƒç”¨å¼‚å¸¸: {str(e)}")
            raise Exception(f"AI æœåŠ¡ä¸å¯ç”¨: {str(e)}")

ai_client = AIProvider()

# ============= æ•°æ®åº“åˆå§‹åŒ– =============

def init_database():
    os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    # API è¡¨ (å¢å¼ºç‰ˆ)
    cursor.execute('''CREATE TABLE IF NOT EXISTS apis (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        path TEXT NOT NULL,
        method TEXT NOT NULL,
        summary TEXT,
        description TEXT,
        base_url TEXT,
        parameters TEXT, -- JSON å­˜å‚¨
        request_body TEXT, -- JSON å­˜å‚¨
        project_id TEXT DEFAULT 'default-project',
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )''')
    
    # è‡ªåŠ¨è¿ç§»æ—§åº“ï¼šå¢åŠ ç¼ºå¤±çš„åˆ—
    try:
        cursor.execute("ALTER TABLE apis ADD COLUMN base_url TEXT")
        cursor.execute("ALTER TABLE apis ADD COLUMN parameters TEXT")
        cursor.execute("ALTER TABLE apis ADD COLUMN request_body TEXT")
        cursor.execute("ALTER TABLE apis ADD COLUMN headers TEXT")  # æ–°å¢headerså­—æ®µ
    except:
        pass # åˆ—å·²å­˜åœ¨
    
    # åœºæ™¯è¡¨
    cursor.execute('''CREATE TABLE IF NOT EXISTS scenarios (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        description TEXT,
        natural_language_input TEXT,
        project_id TEXT DEFAULT 'default-project',
        nlu_result TEXT,
        test_case_id INTEGER,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )''')
    
    # æµ‹è¯•ç”¨ä¾‹è¡¨ (æ­¥éª¤åºåˆ—)
    cursor.execute('''CREATE TABLE IF NOT EXISTS test_cases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        steps TEXT, -- JSON å­˜å‚¨æ­¥éª¤
        project_id TEXT DEFAULT 'default-project',
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )''')
    
    # æ‰§è¡Œè®°å½•è¡¨
    cursor.execute('''CREATE TABLE IF NOT EXISTS executions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        test_case_id INTEGER,
        status TEXT, -- success, fail, running
        results TEXT, -- JSON å­˜å‚¨å„æ­¥è¯¦æƒ…
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )''')
    
    # é¡¹ç›®ç¯å¢ƒé…ç½®è¡¨
    cursor.execute('''CREATE TABLE IF NOT EXISTS project_environments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_id TEXT NOT NULL,
        env_name TEXT NOT NULL, -- å¦‚ test, dev, prod
        base_url TEXT NOT NULL,
        is_default INTEGER DEFAULT 0,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(project_id, env_name)
    )''')
    
    conn.commit()
    conn.close()
    print(f"âœ… æ•°æ®åº“æ¶æ„å·²å°±ç»ª: {DB_PATH}")

init_database()

# ============= æ ¸å¿ƒä¸šåŠ¡è·¯ç”± =============

# --- åœºæ™¯ä¸ç”¨ä¾‹ç”Ÿæˆ ---

class ScenarioCreateRequest(BaseModel):
    natural_language_input: str
    project_id: str = "default-project"

@app.post("/api/v1/scenarios")
async def create_scenario(req: ScenarioCreateRequest):
    """åœºæ™¯ç†è§£å¹¶æœç´¢ API"""
    try:
        print(f"ğŸ” æ”¶åˆ°åœºæ™¯åˆ›å»ºè¯·æ±‚: {req.natural_language_input}")
        # 1. AI ç†è§£æ„å›¾
        system_prompt = "ä½ æ˜¯ä¸€ä¸ªæ¥å£æµ‹è¯•ä¸“å®¶ã€‚è¯·è§£æç”¨æˆ·æè¿°çš„æµ‹è¯•åœºæ™¯ï¼Œæå–æ„å›¾ã€æ¶‰åŠå®ä½“å’ŒåŠ¨ä½œåºåˆ—ã€‚ä»¥ JSON æ ¼å¼è¿”å›ï¼š{intent, entities, actions, expected_results}"
        nlu_result = await ai_client.chat(system_prompt, req.natural_language_input)
        print(f"âœ… AI ç†è§£å®Œæˆ: {nlu_result.get('intent')}")
        
        # 2. ä¿å­˜åœºæ™¯
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO scenarios (name, natural_language_input, nlu_result, project_id) VALUES (?, ?, ?, ?)",
            (nlu_result.get("intent", "æœªå‘½ååœºæ™¯"), req.natural_language_input, json.dumps(nlu_result), req.project_id)
        )
        scenario_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return {"id": scenario_id, "name": nlu_result.get("intent"), "description": req.natural_language_input}
    except Exception as e:
        print(f"âŒ åœºæ™¯åˆ›å»ºå¤±è´¥: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/api/v1/scenarios/{scenario_id}")
async def delete_scenario(scenario_id: int):
    """åˆ é™¤åœºæ™¯åŠå…¶å…³è”çš„æµ‹è¯•ç”¨ä¾‹"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # è·å–å…³è”çš„ test_case_id
        cursor.execute("SELECT test_case_id FROM scenarios WHERE id = ?", (scenario_id,))
        row = cursor.fetchone()
        
        # åˆ é™¤åœºæ™¯
        cursor.execute("DELETE FROM scenarios WHERE id = ?", (scenario_id,))
        
        # å¦‚æœæœ‰æµ‹è¯•ç”¨ä¾‹ï¼Œä¹Ÿä¸€å¹¶åˆ é™¤
        if row and row[0]:
            cursor.execute("DELETE FROM test_cases WHERE id = ?", (row[0],))
            
        conn.commit()
        conn.close()
        return {"success": True}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# --- ç¯å¢ƒé…ç½®ç®¡ç† ---

class EnvironmentBase(BaseModel):
    env_name: str
    base_url: str
    is_default: Optional[bool] = False

@app.get("/api/v1/projects/{project_id}/environments")
async def list_environments(project_id: str):
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM project_environments WHERE project_id = ?", (project_id,))
    rows = cursor.fetchall()
    conn.close()
    return [dict(row) for row in rows]

@app.post("/api/v1/projects/{project_id}/environments")
async def save_environment(project_id: str, env: EnvironmentBase):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    try:
        # å¦‚æœæ ‡è®°ä¸ºé»˜è®¤ï¼Œå…ˆå–æ¶ˆè¯¥é¡¹ç›®å…¶ä»–é»˜è®¤
        if env.is_default:
            cursor.execute("UPDATE project_environments SET is_default = 0 WHERE project_id = ?", (project_id,))
            
        cursor.execute("""
            INSERT INTO project_environments (project_id, env_name, base_url, is_default)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(project_id, env_name) DO UPDATE SET
                base_url = excluded.base_url,
                is_default = excluded.is_default
        """, (project_id, env.env_name, env.base_url, 1 if env.is_default else 0))
        conn.commit()
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        conn.close()
    return {"success": True}

@app.delete("/api/v1/projects/{project_id}/environments/{env_name}")
async def delete_environment(project_id: str, env_name: str):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("DELETE FROM project_environments WHERE project_id = ? AND env_name = ?", (project_id, env_name))
    conn.commit()
    conn.close()
    return {"success": True}

@app.get("/api/v1/scenarios")
async def list_scenarios():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute("""
        SELECT s.*, t.steps as test_case_steps 
        FROM scenarios s 
        LEFT JOIN test_cases t ON s.test_case_id = t.id 
        ORDER BY s.created_at DESC
    """)
    rows = cursor.fetchall()
    conn.close()
    return [dict(row) for row in rows]

@app.post("/api/v1/scenarios/{scenario_id}/generate-case")
async def generate_case(scenario_id: int):
    """ä»æµ·é‡ API ä¸­æ£€ç´¢å¹¶æ™ºèƒ½ç¼–æ’ç”¨ä¾‹é“¾"""
    try:
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # 1. è·å–åœºæ™¯ä¿¡æ¯
        cursor.execute("SELECT * FROM scenarios WHERE id = ?", (scenario_id,))
        scenario = cursor.fetchone()
        if not scenario: raise HTTPException(status_code=404, detail="åœºæ™¯ä¸å­˜åœ¨")
        
        # 2. RAG: ç®€æ˜“è¯­ä¹‰æ£€ç´¢ (åŒ…å«å®Œæ•´å‚æ•°å’Œè¯·æ±‚ä½“ä»¥ä¾› AI ç²¾å‡†è¯†åˆ«)
        cursor.execute("""
            SELECT path, method, summary, description, base_url, parameters, request_body 
            FROM apis 
            WHERE project_id = ?
        """, (scenario["project_id"],))
        rows_apis = cursor.fetchall()
        all_apis = [dict(row) for row in rows_apis]
        
        # 3. AI ç¼–æ’
        system_prompt = """ä½ æ˜¯ä¸€ä¸ªé«˜çº§æ¥å£è‡ªåŠ¨åŒ–ä¸“å®¶ã€‚
        ä»»åŠ¡ï¼šæ ¹æ®ç»™å‡ºçš„ã€ä¸šåŠ¡æ„å›¾ã€‘å’Œã€å¯ç”¨ API åˆ—è¡¨ã€‘ï¼Œè‡ªåŠ¨è¯†åˆ«å‡ºæ­£ç¡®çš„è°ƒç”¨é“¾ï¼Œå¹¶ä»¥ JSON æ ¼å¼è¿”å›ã€‚
        è¦æ±‚ï¼š
        1. è¯†åˆ«å‚æ•°ä¾èµ–ï¼ˆå¦‚ A æ¥å£è¿”å›çš„ id æ˜¯ B æ¥å£çš„è¾“å…¥ï¼‰ã€‚
        2. ç”ŸæˆçœŸå®çš„æµ‹è¯•æ•°æ®ï¼ˆå¦‚æœæ˜¯æŸ¥è¯¢ï¼Œä½¿ç”¨å…¸å‹å€¼ï¼›å¦‚æœæ˜¯åˆ›å»ºï¼Œä½¿ç”¨éšæœºä½†åˆç†çš„å§“å/æ‰‹æœºå·ç­‰ï¼‰ã€‚
        3. è‡ªåŠ¨ç”Ÿæˆé€»è¾‘æ–­è¨€ã€‚è¯·éµå¾ªä»¥ä¸‹æ–­è¨€è§„èŒƒï¼š
           - ç±»å‹ (type) å¿…é¡»æ˜¯ä»¥ä¸‹ä¹‹ä¸€ï¼š'status_code', 'field_value', 'response_contains', 'field_exists', 'json_path'ã€‚
           - 'json_path' å’Œ 'field_value' ä½œç”¨ç›¸åŒï¼Œéƒ½ä½¿ç”¨ç‚¹è®°å·ï¼ˆå¦‚ 'data.list.0.id'ï¼‰è®¿é—®å­—æ®µã€‚
           - å¯¹äºä¸šåŠ¡æˆåŠŸæ ¡éªŒï¼Œè¯·ä¼˜å…ˆä½¿ç”¨ 'field_value' (å¦‚æ ¡éªŒ code=0) æˆ– 'response_contains' (å¦‚åŒ…å« "æˆåŠŸ")ã€‚
           - ä¸¥ç¦ä½¿ç”¨è‡ªå®šä¹‰ä¸­æ–‡ä½œä¸º typeã€‚
        è¯·åŠ¡å¿…è¿”å›åˆæ³•çš„ JSON å¯¹è±¡ã€‚
        æ ¼å¼ï¼š{ "scenario_name": "åç§°", "steps": [{ "step_order": 1, "api_path": "/path", "api_method": "POST", "description": "...", "params": {}, "headers": {}, "assertions": [{"type": "status_code", "expected": 200}, {"type": "field_value", "field": "code", "expected": 0}], "param_mappings": [] }] }"""
        
        user_prompt = f"æ„å›¾: {scenario['nlu_result']}\nå¯ç”¨ API: {json.dumps(all_apis[:50])}" # é™åˆ¶ä¸Šä¸‹æ–‡
        case_result = await ai_client.chat(system_prompt, user_prompt)
        
        # 4. ä¿å­˜æµ‹è¯•ç”¨ä¾‹
        cursor.execute(
            "INSERT INTO test_cases (name, steps, project_id) VALUES (?, ?, ?)",
            (case_result.get("scenario_name"), json.dumps(case_result.get("steps")), scenario["project_id"])
        )
        case_id = cursor.lastrowid
        
        # å…³è”åœºæ™¯
        cursor.execute("UPDATE scenarios SET test_case_id = ? WHERE id = ?", (case_id, scenario_id))
        
        conn.commit()
        conn.close()
        # å…¼å®¹å‰ç«¯å­—æ®µå
        case_result["name"] = case_result.get("scenario_name")
        return case_result
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

# --- æ‰§è¡Œå¼•æ“ ---

class ExecutionRequest(BaseModel):
    test_case_id: Optional[int] = None  # å¯é€‰,ç”¨äºå®Œæ•´åœºæ™¯æ‰§è¡Œ
    environment: str = "test"
    base_url: str = "http://localhost:8000"
    steps: Optional[List[Dict]] = None  # å¯é€‰,ç”¨äºå•æ­¥æ‰§è¡Œ

@app.post("/api/v1/executions")
async def execute_case(req: ExecutionRequest):
    """é“¾å¼æ‰§è¡Œå¼•æ“ï¼šæ”¯æŒå˜é‡åŠ¨æ€æ˜ å°„å’Œ HTTP å‘é€"""
    try:
        # å¦‚æœç›´æ¥æä¾›äº†steps,åˆ™ä½¿ç”¨å®ƒ(å•æ­¥æ‰§è¡Œ)
        if req.steps:
            steps = req.steps
        else:
            # å¦åˆ™ä»æ•°æ®åº“è¯»å–(å®Œæ•´åœºæ™¯æ‰§è¡Œ)
            if not req.test_case_id:
                raise HTTPException(status_code=400, detail="å¿…é¡»æä¾› test_case_id æˆ– steps")
            
            conn = sqlite3.connect(DB_PATH)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            cursor.execute("SELECT * FROM test_cases WHERE id = ?", (req.test_case_id,))
            case = cursor.fetchone()
            if not case: 
                conn.close()
                raise HTTPException(status_code=404, detail="ç”¨ä¾‹ä¸å­˜åœ¨")
            
            steps = json.loads(case["steps"])
            conn.close()
        
        context = {} # å­˜å‚¨è¿è¡Œæ—¶å˜é‡ï¼Œå¦‚ {step1: {response: {...}}}
        step_results = []
        
        # åˆ›å»ºHTTPå®¢æˆ·ç«¯,ç¦ç”¨SSLéªŒè¯
        async with httpx.AsyncClient(
            verify=False,      # ç¦ç”¨SSLéªŒè¯
            timeout=30.0,      # 30ç§’è¶…æ—¶
            follow_redirects=True  # è·Ÿéšé‡å®šå‘
        ) as client:
            for step in steps:
                step_order = step.get("step_order", 0)
                start_time = datetime.now()
                # 1. ç¡®å®š Base URL
                current_base_url = req.base_url.strip() if req.base_url else ""
                if not current_base_url or current_base_url == "http://localhost:8000":
                    if step.get("base_url"):
                        current_base_url = step.get("base_url").strip()

                # å®šä¹‰é¢„æœŸçš„æ­¥éª¤æ•°æ®ï¼ˆå³ä½¿å¤±è´¥ä¹Ÿè¦è®°å½•ï¼‰
                step_data = {
                    "step_order": step_order,
                    "url": "",
                    "method": step.get("api_method", "GET").upper(),
                    "request_data": step.get("params", {}),
                    "success": False,
                    "status_code": "Error",
                    "extractions": []  # æ–°å¢:æå–è®°å½•
                }
                
                try:
                    # 1. å˜é‡æ›¿æ¢ä¸å‚æ•°å‡†å¤‡
                    api_path = step.get('api_path', '')
                    # å¼ºè½¬ç è·¯å¾„éƒ¨åˆ†ï¼Œé˜²æ­¢é ASCII å­—ç¬¦æŠ›å‡º Invalid non-printable ASCII character
                    safe_path = urllib.parse.quote(api_path.lstrip('/'), safe="/?=&")
                    url = f"{current_base_url.rstrip('/')}/{safe_path}"
                    
                    params = step.get("params", {}).copy()
                    method = step_data["method"]
                    
                    # å¤„ç† URL å‚æ•° (query å’Œ path)
                    query_params = {}
                    url_params_list = step.get("url_params", [])
                    if isinstance(url_params_list, list):
                        for p in url_params_list:
                            p_name = p.get("name")
                            p_in = p.get("in")
                            p_val = p.get("value")
                            if p_val is None:
                                # å°è¯•è·å–é»˜è®¤å€¼
                                schema = p.get("schema", {})
                                p_val = schema.get("default") if isinstance(schema, dict) else None
                            
                            if p_val is not None:
                                if p_in == "path":
                                    # æ›¿æ¢è·¯å¾„å‚æ•° {name} æˆ– :name
                                    url = url.replace(f"{{{p_name}}}", str(p_val))
                                    url = url.replace(f":{p_name}", str(p_val))
                                elif p_in == "query":
                                    query_params[p_name] = p_val
                    elif isinstance(url_params_list, dict):
                        # å¦‚æœæ˜¯å­—å…¸,ç›´æ¥ä½œä¸º query å‚æ•°
                        query_params.update(url_params_list)

                    step_data["url"] = url
                    
                    # å¤„ç†headers
                    headers = step.get("headers", {}).copy()
                    
                    # å¤„ç†å‚æ•°æ˜ å°„(åŒ…æ‹¬ headersä¸­çš„å˜é‡æ›¿æ¢)å¹¶è®°å½•æå–è¿‡ç¨‹
                    extractions = []
                    for mapping in step.get("param_mappings", []):
                        from_step_idx = mapping.get("from_step")
                        from_field = mapping.get("from_field")
                        to_field = mapping.get("to_field")
                        
                        # åˆå§‹åŒ–æå–è®°å½•
                        extraction = {
                            "from_step": from_step_idx,
                            "from_field": from_field,
                            "to_field": to_field,
                            "extracted_value": None,
                            "success": False,
                            "error_msg": ""
                        }
                        
                        if from_step_idx is None or to_field is None:
                            extraction["error_msg"] = "å‚æ•°æ˜ å°„é…ç½®ä¸å®Œæ•´"
                            extractions.append(extraction)
                            continue
                        
                        
                        from_data = context.get(f"step_{from_step_idx}", {}).get("response")
                        
                        # è°ƒè¯•æ—¥å¿—ï¼šè¾“å‡ºåŸå§‹å“åº”æ•°æ®
                        print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {from_step_idx} çš„å“åº”æ•°æ®ç±»å‹: {type(from_data)}")
                        print(f"ğŸ” æå–è°ƒè¯• - å“åº”æ•°æ®keys: {list(from_data.keys()) if isinstance(from_data, dict) else 'N/A'}")
                        print(f"ğŸ” æå–è°ƒè¯• - æå–è·¯å¾„: {from_field}")
                        
                        if isinstance(from_data, dict):
                            # æ”¯æŒåµŒå¥—è·¯å¾„æå–ï¼Œå¦‚ data.list[0].singer
                            field_val = None
                            try:
                                # è§£æè·¯å¾„ï¼Œæ”¯æŒç‚¹å·å’Œæ•°ç»„ç´¢å¼•
                                current = from_data
                                parts = from_field.split('.')
                                
                                print(f"ğŸ” æå–è°ƒè¯• - è·¯å¾„åˆ†å‰²: {parts}")
                                
                                for i, part in enumerate(parts):
                                    if current is None:
                                        print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: current ä¸º Noneï¼Œåœæ­¢è§£æ")
                                        break
                                    
                                    print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: å¤„ç†éƒ¨åˆ† '{part}', å½“å‰ç±»å‹: {type(current)}")
                                    
                                    # å¤„ç†æ•°ç»„ç´¢å¼•ï¼Œå¦‚ list[0]
                                    if '[' in part and ']' in part:
                                        key = part[:part.index('[')]
                                        index_str = part[part.index('[')+1:part.index(']')]
                                        
                                        print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: æ•°ç»„è®¿é—® key='{key}', index='{index_str}'")
                                        
                                        # å…ˆè·å–æ•°ç»„
                                        if isinstance(current, dict):
                                            current = current.get(key)
                                            print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: è·å–å­—æ®µ '{key}', ç»“æœç±»å‹: {type(current)}")
                                        
                                        # å†è·å–ç´¢å¼•
                                        if isinstance(current, list):
                                            try:
                                                index = int(index_str)
                                                if 0 <= index < len(current):
                                                    current = current[index]
                                                    print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: è·å–ç´¢å¼• [{index}], ç»“æœç±»å‹: {type(current)}")
                                                else:
                                                    current = None
                                                    print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: ç´¢å¼•è¶Šç•Œ [{index}], æ•°ç»„é•¿åº¦: {len(current)}")
                                            except (ValueError, IndexError) as e:
                                                current = None
                                                print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: ç´¢å¼•è§£æå¤±è´¥: {e}")
                                        else:
                                            current = None
                                            print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: ä¸æ˜¯æ•°ç»„ï¼Œæ— æ³•è·å–ç´¢å¼•")
                                    # å¤„ç†çº¯æ•°å­—ï¼ˆç‚¹å·æ ¼å¼çš„æ•°ç»„ç´¢å¼•ï¼Œå¦‚ list.0ï¼‰
                                    elif part.isdigit():
                                        print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: æ£€æµ‹åˆ°çº¯æ•°å­— '{part}'ï¼Œä½œä¸ºæ•°ç»„ç´¢å¼•")
                                        if isinstance(current, list):
                                            try:
                                                index = int(part)
                                                if 0 <= index < len(current):
                                                    current = current[index]
                                                    print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: è·å–ç´¢å¼• [{index}], ç»“æœç±»å‹: {type(current)}")
                                                else:
                                                    current = None
                                                    print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: ç´¢å¼•è¶Šç•Œ [{index}], æ•°ç»„é•¿åº¦: {len(current)}")
                                            except (ValueError, IndexError) as e:
                                                current = None
                                                print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: ç´¢å¼•è§£æå¤±è´¥: {e}")
                                        else:
                                            # ä¸æ˜¯æ•°ç»„ï¼Œå°è¯•ä½œä¸ºå­—æ®µå
                                            if isinstance(current, dict):
                                                current = current.get(part)
                                                print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: ä½œä¸ºå­—æ®µåè·å– '{part}', ç»“æœ: {current}")
                                            else:
                                                current = None
                                                print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: æ—¢ä¸æ˜¯æ•°ç»„ä¹Ÿä¸æ˜¯å­—å…¸")
                                    else:
                                        # æ™®é€šå­—æ®µè®¿é—®
                                        if isinstance(current, dict):
                                            current = current.get(part)
                                            print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: è·å–å­—æ®µ '{part}', ç»“æœ: {current}")
                                        else:
                                            current = None
                                            print(f"ğŸ” æå–è°ƒè¯• - æ­¥éª¤ {i}: ä¸æ˜¯å­—å…¸ï¼Œæ— æ³•è·å–å­—æ®µ '{part}'")
                                
                                field_val = current
                                print(f"ğŸ” æå–è°ƒè¯• - æœ€ç»ˆæå–å€¼: {field_val}")
                            except Exception as e:
                                extraction["error_msg"] = f"è·¯å¾„è§£æå¤±è´¥: {str(e)}"
                                print(f"ğŸ” æå–è°ƒè¯• - å¼‚å¸¸: {e}")
                            
                            if field_val is not None:
                                extraction["extracted_value"] = field_val
                                extraction["success"] = True
                                # æ”¯æŒheadersä¸­çš„å˜é‡æ›¿æ¢
                                if to_field.startswith("headers."):
                                    header_key = to_field.replace("headers.", "")
                                    headers[header_key] = field_val
                                else:
                                    params[to_field] = field_val
                            else:
                                if not extraction["error_msg"]:
                                    extraction["error_msg"] = f"å­—æ®µ {from_field} ä¸å­˜åœ¨æˆ–å€¼ä¸º null"
                        else:
                            extraction["error_msg"] = f"æ­¥éª¤ {from_step_idx} çš„å“åº”æ•°æ®ä¸æ˜¯å­—å…¸ç±»å‹"
                        
                        extractions.append(extraction)
                    
                    step_data["extractions"] = extractions
                    
                    # å¤„ç†headersä¸­çš„å˜é‡å¼•ç”¨ ${stepX.field}
                    for key, value in list(headers.items()):
                        if isinstance(value, str) and "${" in value:
                            matches = re.findall(r'\$\{step(\d+)\.(.+?)\}', value)
                            for step_idx, field_path in matches:
                                step_data_ref = context.get(f"step_{step_idx}", {}).get("response", {})
                                field_value = step_data_ref
                                for part in field_path.split('.'):
                                    if isinstance(field_value, dict):
                                        field_value = field_value.get(part)
                                    else:
                                        field_value = None
                                        break
                                if field_value:
                                    value = value.replace(f"${{step{step_idx}.{field_path}}}", str(field_value))
                            headers[key] = value

                    step_data["request_data"] = params
                    
                    # 2. å‘é€è¯·æ±‚
                    print(f"ğŸš€ æ‰§è¡Œæ­¥éª¤ {step_order}: {method} {url}")
                    if query_params:
                        print(f"   æŸ¥è¯¢å‚æ•°: {json.dumps(query_params, ensure_ascii=False)}")
                    print(f"   è¯·æ±‚ä½“: {json.dumps(params, ensure_ascii=False)[:200]}")
                    
                    try:
                        res = await client.request(
                            method, 
                            url, 
                            params=query_params if method != "GET" else {**query_params, **params}, 
                            json=params if method != "GET" and params else None,
                            headers=headers,
                            timeout=30.0,
                            follow_redirects=True
                        )
                        duration = (datetime.now() - start_time).total_seconds()
                        
                        print(f"   âœ… å“åº”: {res.status_code} ({duration:.2f}s)")
                        
                        # 3. è®°å½•ç»“æœ
                        res_content = res.text
                        try:
                            res_json = res.json()
                            res_content = res_json
                        except:
                            pass
                        
                        # 4. æ‰§è¡Œæ–­è¨€éªŒè¯
                        assertions_config = step.get("assertions", [])
                        assertion_results = []
                        
                        # å¦‚æœAIæ²¡æœ‰ç”Ÿæˆæ–­è¨€,æ·»åŠ é»˜è®¤æ–­è¨€
                        if not assertions_config:
                            assertions_config = [
                                {
                                    "type": "status_code",
                                    "operator": "equals",
                                    "expected_value": 200,
                                    "description": "çŠ¶æ€ç åº”ä¸º200"
                                },
                                {
                                    "type": "response_time",
                                    "operator": "less_than",
                                    "expected_value": 1000,
                                    "description": "å“åº”æ—¶é—´åº”å°äº1ç§’"
                                }
                            ]
                        
                        # éªŒè¯æ¯ä¸ªæ–­è¨€
                        for assertion in assertions_config:
                            assertion_type = assertion.get("type", "")
                            # æ”¯æŒexpectedå’Œexpected_valueä¸¤ç§å­—æ®µå
                            expected = assertion.get("expected") or assertion.get("expected_value")
                            description = assertion.get("description", "")
                            
                            result = {
                                "type": assertion_type,
                                "description": description,
                                "expected": expected,
                                "actual": None,
                                "passed": False
                            }
                            
                            try:
                                if assertion_type == "status_code":
                                    result["actual"] = res.status_code
                                    result["passed"] = (res.status_code == expected)
                                
                                elif assertion_type == "response_time":
                                    actual_ms = duration * 1000
                                    result["actual"] = f"{actual_ms:.0f}ms"
                                    result["passed"] = (actual_ms < expected)
                                
                                elif assertion_type == "field_exists":
                                    field = assertion.get("field", "")
                                    if isinstance(res_content, dict):
                                        # æ”¯æŒåµŒå¥—å­—æ®µ,å¦‚ "data.user.id"
                                        field_exists = True
                                        current = res_content
                                        for part in field.split("."):
                                            if isinstance(current, dict) and part in current:
                                                current = current[part]
                                            else:
                                                field_exists = False
                                                break
                                        result["actual"] = field_exists
                                        result["passed"] = field_exists
                                    else:
                                        result["actual"] = False
                                        result["passed"] = False
                                
                                elif assertion_type in ["field_value", "json_path"]:
                                    # æ”¯æŒ field, expression, path, json_path ç­‰å­—æ®µå
                                    field_raw = assertion.get("field") or assertion.get("expression") or assertion.get("path") or assertion.get("json_path", "")
                                    # æ¸…ç† JSONPath å‰ç¼€
                                    field = str(field_raw).strip()
                                    if field.startswith("$."): field = field[2:]
                                    elif field.startswith("$"): field = field[1:]
                                    
                                    if isinstance(res_content, dict):
                                        current = res_content
                                        parts = field.split(".")
                                        
                                        # æ™ºèƒ½å¤„ç†: å¦‚æœç¬¬ä¸€çº§æ˜¯ 'data' ä½†å“åº”æ ¹éƒ¨æ²¡æœ‰ 'data'ï¼Œå°è¯•è·³è¿‡å®ƒ
                                        if parts and parts[0] == "data" and "data" not in current and len(parts) > 1:
                                            parts = parts[1:]
                                        
                                        for part in parts:
                                            # å¤„ç†å‡½æ•°å¦‚ length()
                                            if part.endswith("()"):
                                                func = part[:-2].lower()
                                                if func == "length":
                                                    current = len(current) if isinstance(current, (list, dict, str)) else 0
                                                    continue
                                            
                                            # å¤„ç†æ•°ç»„ç´¢å¼•å¦‚ "data.list.0"
                                            if isinstance(current, list) and part.isdigit():
                                                idx = int(part)
                                                current = current[idx] if idx < len(current) else None
                                            elif isinstance(current, dict):
                                                # å°è¯•åŒ¹é…åŸæ · key
                                                if part in current:
                                                    current = current[part]
                                                # å°è¯•å¤„ç† songs vs song è¿™ç§å•å¤æ•°ä¸ä¸€è‡´æƒ…å†µ (ç®€å•çš„æ¨¡ç³ŠåŒ¹é…)
                                                elif part.endswith("s") and part[:-1] in current:
                                                    current = current[part[:-1]]
                                                else:
                                                    current = None
                                                    break
                                            else:
                                                current = None
                                                break
                                        
                                        result["actual"] = current
                                        
                                        # å¦‚æœæ²¡æœ‰æä¾› expected, åˆ™é€€åŒ–ä¸º field_exists é€»è¾‘
                                        if expected is None:
                                            # åˆ¤å®šæ ‡å‡†ï¼šä¸ä¸º None ä¸”ï¼ˆå¦‚æœæ˜¯åˆ—è¡¨åˆ™éç©ºï¼‰
                                            result["passed"] = (current is not None and not (isinstance(current, list) and len(current) == 0))
                                            result["description"] = f"æ ¡éªŒå­—æ®µ {field_raw} æ˜¯å¦å­˜åœ¨ä¸”ä¸ä¸ºç©º"
                                        else:
                                            # ç»Ÿä¸€è½¬ä¸ºå­—ä¸²æ¯”è¾ƒï¼Œå¢å¼ºå…¼å®¹æ€§
                                            result["passed"] = (str(current) == str(expected))
                                    else:
                                        result["actual"] = None
                                        result["passed"] = False
                                
                                elif assertion_type == "response_contains":
                                    text = str(assertion.get("text", "") or expected or "")
                                    contains = text in str(res_content)
                                    result["actual"] = f"åŒ…å« '{text}'" if contains else "ä¸åŒ…å«"
                                    result["passed"] = contains
                                
                                else:
                                    # æœªçŸ¥æˆ–è¯­ä¹‰ç±»å‹å¤„ç† (å¦‚ "ç™»å½•æˆåŠŸ")
                                    # å°è¯• 1: åœ¨å“åº”ä¸­æŸ¥æ‰¾ç›¸å…³å…³é”®å­— (åŸé€»è¾‘)
                                    keywords = [assertion_type, description]
                                    matches = any(kw and kw in str(res_content) for kw in keywords)
                                    
                                    # å°è¯• 2: è¯­ä¹‰åŒ–æˆåŠŸåˆ¤å®šã€‚å¦‚æœæ–­è¨€æ¶‰åŠ "æˆåŠŸ", "å®Œæˆ", "OK", "æœ‰æ•ˆ" ç­‰
                                    success_keywords = ["æˆåŠŸ", "å®Œæˆ", "OK", "æœ‰æ•ˆ", "success", "ok", "valid"]
                                    is_success_assertion = any(sk in assertion_type or sk in description for sk in success_keywords)
                                    
                                    if not matches and is_success_assertion:
                                        # å¦‚æœæ˜¯æˆåŠŸç±»æ–­è¨€ä½†æ²¡åŒ¹é…åˆ°å…³é”®å­—ï¼Œæ£€æŸ¥å¸¸è§çš„æˆåŠŸæ ‡å¿—
                                        if isinstance(res_content, dict):
                                            # æ£€æŸ¥ code/status/success ç­‰å¸¸è§å­—æ®µ
                                            code = res_content.get("code")
                                            is_success_code = code in [0, 200, "0", "200"]
                                            is_success_bool = res_content.get("success") is True or res_content.get("status") in ["success", "ok"]
                                            
                                            if is_success_code or is_success_bool:
                                                matches = True
                                                result["actual"] = f"åŒ¹é…ä¸šåŠ¡æˆåŠŸæ ‡å¿— (code={code})" if is_success_code else "åŒ¹é…ä¸šåŠ¡æˆåŠŸçŠ¶æ€"
                                    
                                    # åªæœ‰åœ¨ actual è¿˜æ²¡è¢«èµ‹å€¼(å³æœªçŸ¥æ–­è¨€ç±»å‹)æ—¶ï¼Œæ‰ä½¿ç”¨æ¨¡ç³ŠåŒ¹é…çš„ç»“æœ
                                    if result.get("actual") is None and assertion_type not in ["status_code", "field_value", "json_path", "field_exists", "response_contains"]:
                                        result["actual"] = "éƒ¨åˆ†åŒ¹é…" if matches else "æ— åŒ¹é…"
                                        result["passed"] = matches if keywords else True
                                    if not matches:
                                        print(f"   âš ï¸ æœªçŸ¥æ–­è¨€ç±»å‹: {assertion_type}, åŒ¹é…å¤±è´¥")
                                
                            except Exception as e:
                                result["error"] = str(e)
                                result["passed"] = False
                            
                            assertion_results.append(result)
                        
                        # åˆ¤æ–­æ­¥éª¤æ˜¯å¦æˆåŠŸ(æ‰€æœ‰æ–­è¨€éƒ½é€šè¿‡)
                        all_assertions_passed = all(a["passed"] for a in assertion_results)
                            
                        step_data.update({
                            "status_code": res.status_code,
                            "duration": duration,
                            "response": res_content,
                            "response_headers": dict(res.headers),  # æ–°å¢:å“åº”å¤´
                            "assertions": assertion_results,
                            "success": res.status_code < 400 and all_assertions_passed
                        })
                        context[f"step_{step_order}"] = step_data
                        step_results.append(step_data)
                        
                    except httpx.TimeoutException as e:
                        error_msg = f"è¯·æ±‚è¶…æ—¶: {repr(e)}"
                        print(f"   âŒ {error_msg}")
                        step_data["error"] = error_msg
                        step_results.append(step_data)
                    except httpx.ConnectError as e:
                        # ConnectErrorçš„str()å¯èƒ½ä¸ºç©º,ä½¿ç”¨repr()è·å–è¯¦ç»†ä¿¡æ¯
                        error_detail = str(e) if str(e) else repr(e)
                        error_msg = f"è¿æ¥å¤±è´¥: {error_detail}"
                        print(f"   âŒ {error_msg}")
                        step_data["error"] = error_msg
                        step_results.append(step_data)
                    except httpx.HTTPStatusError as e:
                        error_msg = f"HTTPé”™è¯¯ {e.response.status_code}: {str(e)}"
                        print(f"   âŒ {error_msg}")
                        step_data["error"] = error_msg
                        step_results.append(step_data)
                    except Exception as e:
                        error_detail = str(e) if str(e) else repr(e)
                        error_msg = f"è¯·æ±‚å¼‚å¸¸: {type(e).__name__}: {error_detail}"
                        print(f"   âŒ {error_msg}")
                        import traceback
                        traceback.print_exc()

                        step_data["error"] = error_msg
                        step_results.append(step_data)
                except Exception as e:
                    error_msg = f"æ­¥éª¤å‡†å¤‡å¼‚å¸¸: {type(e).__name__}: {str(e)}"
                    print(f"âŒ æ­¥éª¤ {step_order} è¿è¡Œå¼‚å¸¸: {error_msg}")
                    step_data["error"] = error_msg
                    # å³ä½¿å‡ºé”™ä¹Ÿè¿”å›å·²å‡†å¤‡å¥½çš„ URL å’Œ Methodï¼Œæ–¹ä¾¿å‰ç«¯å±•ç¤º
                    step_results.append(step_data)

        # 4. ä¿å­˜æ‰§è¡Œè®°å½•å¹¶åˆ¤å®šæ€»çŠ¶æ€
        final_status = "success" if all(s.get("success", False) for s in step_results) else "failed"
        
        # åªæœ‰å®Œæ•´åœºæ™¯æ‰§è¡Œæ‰ä¿å­˜åˆ°æ•°æ®åº“
        if req.test_case_id:
            conn = sqlite3.connect(DB_PATH)
            cursor = conn.cursor()
            cursor.execute(
                "INSERT INTO executions (test_case_id, status, results) VALUES (?, ?, ?)",
                (req.test_case_id, final_status, json.dumps(step_results))
            )
            exec_id = cursor.lastrowid
            conn.commit()
            conn.close()
        else:
            # å•æ­¥æ‰§è¡Œä½¿ç”¨ä¸´æ—¶ID
            exec_id = 0
        
        return {"id": exec_id, "status": final_status, "results": step_results}
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

# --- å¯¼å…¥ä¸åˆ—è¡¨ (ä¿æŒåŸæœ‰é€»è¾‘) ---

@app.get("/api/v1/projects")
async def list_projects():
    """è·å–ç³»ç»Ÿä¸­æ‰€æœ‰é¡¹ç›® ID"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("SELECT DISTINCT project_id FROM apis UNION SELECT DISTINCT project_id FROM scenarios")
    rows = cursor.fetchall()
    conn.close()
    return {"projects": [r[0] for r in rows if r[0]]}

@app.post("/api/v1/import/swagger")
async def import_swagger(project_id: str = Form("default-project"), source: str = Form(None), file: UploadFile = File(None)):
    try:
        swagger_data = None
        if source:
            async with httpx.AsyncClient() as client:
                res = await client.get(source)
                swagger_data = res.json()
        elif file:
            content = await file.read()
            swagger_data = json.loads(content)
        
        if not swagger_data: return {"success": False, "message": "æ— æ•°æ®"}
        
        apis = []
        paths = swagger_data.get("paths", {})
        
        # æå–åŸŸå (Base URL)
        servers = swagger_data.get("servers", [])
        base_url = servers[0].get("url", "") if servers else ""

        for path, methods in paths.items():
            # æå–è·¯å¾„çº§åˆ«çš„é€šç”¨å‚æ•° (Path-level parameters)
            path_params = methods.get("parameters", [])
            
            for method, details in methods.items():
                if method.lower() in ["get", "post", "put", "delete", "patch"]:
                    # åˆå¹¶è·¯å¾„çº§å‚æ•°å’Œæ–¹æ³•çº§å‚æ•°
                    all_params = path_params + details.get("parameters", [])
                    
                    # åˆå§‹åŒ– headersï¼ˆåªå­˜å‚¨ Swagger ä¸­å®šä¹‰çš„ï¼‰
                    headers = {}
                    url_params = []
                    
                    # å¤„ç† Swagger ä¸­å®šä¹‰çš„ header parameters
                    for param in all_params:
                        param_in = param.get("in", "")
                        if param_in == "header":
                            headers[param.get("name")] = param.get("schema", {}).get("default", "")
                        else:
                            url_params.append({
                                "name": param.get("name"),
                                "in": param_in,
                                "required": param.get("required", False),
                                "schema": param.get("schema", {}),
                                "description": param.get("description", "")
                            })

                    # é’ˆå¯¹å†™æ“ä½œè‡ªåŠ¨è¡¥å…¨ Content-Typeï¼ˆåŸºäº requestBodyï¼‰
                    if method.lower() in ["post", "put", "patch"]:
                        request_body = details.get("requestBody", {})
                        if request_body:
                            content_types = request_body.get("content", {})
                            if content_types:
                                # æ‰¾åˆ°ç¬¬ä¸€ä¸ªé null çš„ content-type
                                for ct in content_types.keys():
                                    if ct and str(ct).lower() != "null":
                                        headers["Content-Type"] = ct
                                        break
                                # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„ content-typeï¼Œä½¿ç”¨é»˜è®¤å€¼
                                if "Content-Type" not in headers:
                                    headers["Content-Type"] = "application/json"
                    
                    apis.append((
                        path, 
                        method.upper(), 
                        details.get("summary", ""), 
                        details.get("description", ""), 
                        base_url,
                        json.dumps(url_params),  # åªå­˜å‚¨éheaderå‚æ•°
                        json.dumps(details.get("requestBody", {})),
                        json.dumps(headers),  # å•ç‹¬å­˜å‚¨headers
                        project_id
                    ))
        
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM apis WHERE project_id = ?", (project_id,))
        cursor.executemany("""
            INSERT INTO apis (path, method, summary, description, base_url, parameters, request_body, headers, project_id) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, apis)
        conn.commit()
        conn.close()
        
        return {"success": True, "indexed": len(apis), "total": len(apis), "project_id": project_id}
    except Exception as e:
        return {"success": False, "message": str(e)}

@app.get("/api/v1/apis")
async def list_apis():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM apis ORDER BY created_at DESC")
    rows = cursor.fetchall()
    conn.close()
    return {"apis": [
        {
            "id": r["id"], 
            "path": r["path"], 
            "method": r["method"], 
            "name": r["summary"] or r["path"], 
            "description": r["description"],
            "base_url": r["base_url"],
            "parameters": json.loads(r["parameters"] or "[]"),
            "request_body": json.loads(r["request_body"] or "{}"),
            "headers": json.loads(r["headers"] or "{}"),  # æ·»åŠ headerså­—æ®µ
            "project_id": r["project_id"],
            "tags": []
        } for r in rows
    ]}

@app.delete("/api/v1/apis/{api_id}")
async def delete_api(api_id: str):
    """åˆ é™¤å•ä¸ªAPI"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM apis WHERE id = ?", (api_id,))
        deleted = cursor.rowcount
        conn.commit()
        conn.close()
        
        if deleted == 0:
            raise HTTPException(status_code=404, detail="APIä¸å­˜åœ¨")
        
        return {"success": True, "message": "APIåˆ é™¤æˆåŠŸ"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/api/v1/apis/project/{project_id}")
async def delete_apis_by_project(project_id: str):
    """æ‰¹é‡åˆ é™¤æŒ‡å®šé¡¹ç›®çš„æ‰€æœ‰API"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM apis WHERE project_id = ?", (project_id,))
        deleted_count = cursor.rowcount
        conn.commit()
        conn.close()
        
        return {"success": True, "deleted": deleted_count, "message": f"å·²åˆ é™¤ {deleted_count} ä¸ªAPI"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/v1/import/postman")
async def import_postman(file: UploadFile = File(...), project_id: str = Form("default-project")):
    """å¯¼å…¥Postman Collectionæ–‡ä»¶"""
    import tempfile
    
    try:
        # 1. ä¿å­˜ä¸Šä¼ çš„æ–‡ä»¶
        with tempfile.NamedTemporaryFile(delete=False, suffix='.json', mode='wb') as tmp:
            content = await file.read()
            tmp.write(content)
            tmp_path = tmp.name
        
        # 2. è¯»å–å¹¶è§£æCollection
        with open(tmp_path, 'r', encoding='utf-8') as f:
            collection = json.load(f)
        
        # 3. è§£æCollectionä¸­çš„API
        apis = []
        _parse_postman_items(collection.get('item', []), apis, project_id)
        
        # 4. ä¿å­˜åˆ°æ•°æ®åº“
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # åˆ é™¤è¯¥é¡¹ç›®çš„æ—§æ•°æ®
        cursor.execute("DELETE FROM apis WHERE project_id = ?", (project_id,))
        
        # æ’å…¥æ–°æ•°æ®
        for api in apis:
            cursor.execute("""
                INSERT INTO apis (path, method, summary, description, base_url, parameters, request_body, headers, project_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                api['path'],
                api['method'],
                api['name'],
                api.get('description', ''),
                api.get('base_url', ''),
                json.dumps(api.get('parameters', [])),
                json.dumps(api.get('request_body', {})),
                json.dumps(api.get('headers', {})),
                project_id
            ))
        
        conn.commit()
        conn.close()
        
        # 5. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        os.remove(tmp_path)
        
        return {
            "success": True,
            "indexed": len(apis),
            "total": len(apis),
            "project_id": project_id
        }
        
    except Exception as e:
        print(f"âŒ Postmanå¯¼å…¥å¤±è´¥: {str(e)}")
        import traceback
        traceback.print_exc()
        return {
            "success": False,
            "message": str(e)
        }

def _parse_postman_items(items: List, apis: List, project_id: str, folder_path: str = ""):
    """é€’å½’è§£æPostman Collectioné¡¹"""
    for item in items:
        if 'request' in item:
            # è¿™æ˜¯ä¸€ä¸ªè¯·æ±‚
            api = _convert_postman_request(item, folder_path)
            apis.append(api)
        elif 'item' in item:
            # è¿™æ˜¯ä¸€ä¸ªæ–‡ä»¶å¤¹
            new_path = f"{folder_path}/{item['name']}" if folder_path else item['name']
            _parse_postman_items(item['item'], apis, project_id, new_path)

def _convert_postman_request(item: dict, folder_path: str) -> dict:
    """è½¬æ¢Postmanè¯·æ±‚ä¸ºæ ‡å‡†æ ¼å¼"""
    request = item.get('request', {})
    url = request.get('url', {})
    
    # å¤„ç†URL
    if isinstance(url, str):
        path = url
        base_url = ""
    else:
        path = '/' + '/'.join(url.get('path', []))
        # æå–base_url
        protocol = url.get('protocol', 'http')
        host = url.get('host', [])
        if isinstance(host, list):
            base_url = f"{protocol}://{'.'.join(host)}"
        else:
            base_url = f"{protocol}://{host}"
    
    # è§£æå‚æ•°å’ŒHeaders
    parameters = []
    headers = {}
    
    # Queryå‚æ•°
    if isinstance(url, dict):
        for query in url.get('query', []):
            if not query.get('disabled', False):
                parameters.append({
                    "name": query.get('key'),
                    "in": "query",
                    "type": "string",
                    "required": True,
                    "description": query.get('description', '')
                })
    
    # Headerå‚æ•° - å•ç‹¬æå–ä¸ºheaderså­—å…¸
    for header in request.get('header', []):
        if not header.get('disabled', False):
            headers[header.get('key')] = header.get('value', '')
    
    # è§£æè¯·æ±‚ä½“
    request_body = {}
    body = request.get('body', {})
    if body:
        mode = body.get('mode', 'raw')
        if mode == 'raw':
            try:
                raw_data = json.loads(body.get('raw', '{}'))
                request_body = {"schema": raw_data}
            except:
                request_body = {}
        elif mode == 'formdata':
            request_body = {"schema": {"type": "formdata"}}
    
    return {
        "name": item.get('name', ''),
        "path": path,
        "method": request.get('method', 'GET'),
        "description": item.get('description', ''),
        "base_url": base_url,
        "parameters": parameters,
        "request_body": request_body,
        "headers": headers,
        "tags": [folder_path] if folder_path else []
    }

if __name__ == "__main__":
    print(f"ğŸš€ å¯åŠ¨ç»Ÿä¸€åç«¯ (Unified Backend)... æ•°æ®åº“: {DB_PATH}")
    uvicorn.run(app, host="0.0.0.0", port=8000)

